# -*- coding: utf-8 -*-
"""Yelp_TechPoint.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nRt1CAyOfARD2C2hmjmDadkJF6G6pXl-
"""

# Importing Required Packages
import requests
import pandas as pd
from IPython.display import display, HTML
from google.colab import files

# Function to Create a Scrollable Table Within a Small Window
def scroll_table(data, table_id, title):
    html = f'<h3>{title}</h3>'
    html += f'<div id="{table_id}" style="height:400px;overflow:auto;">'
    html += data.to_html()
    html += '</div>'
    return html

# Setting API Key, URL, and Authorization Variables
Yelp_API_Key = 'VNHDNkc75Vtqd-aQI0Dod8QCsNR1FgaMqb-H3oVZf14vGeHjLw9IGTUCwa36_GZjkb1Y0t2Flf9NHEQuUWuu-4I9ylS5HMM3qwfL3kvFc4_F-oaf7llnCoNDjagsZXYx'
search_url = "https://api.yelp.com/v3/businesses/search?sort_by=best_match&limit=50"
Authorization = {'Authorization': 'bearer %s' % Yelp_API_Key}

# Obtaining Yelp Business IDs of Foodtrucks

# Setting Parameters
PARAMS = {'location': 'IN, US',
          'term': 'food truck',
          'categories': 'foodtrucks',
          'offset': 0}

# Scraping Data to Obtain Business ID List
response = requests.get(url = search_url, params = PARAMS, headers = Authorization)
bus_data = response.json()
df = pd.DataFrame(bus_data['businesses'])
id_list = list(df['id'])

# Scraping Data About Food Truck Details

# Creating Empty List to Store Scraped Data
dataframes = []

# Scraping Data of Details of Every Food Truck
for business_id in id_list:

    # Creating Header and Endpoint Variables
    headers = {"Authorization": f"Bearer {Yelp_API_Key}"}
    endpoint = f"https://api.yelp.com/v3/businesses/{business_id}"

    # Scraping Data
    response = requests.get(endpoint, headers=headers)
    if response.status_code == 200:
        business_data = response.json()

        # Obtaining Cuisine Data
        last_category_title = business_data['categories'][-1]['title']

        # Obtaining Start and End Time Hours
        if 'hours' in business_data:
          hours = business_data.get('hours')
          start_time = hours[0]['open'][0]['start']
          end_time = hours[0]['open'][0]['end']
        else:
          start_time = None
          end_time = None

        # Selecting Relevant Data from Business Details
        data = {
            "id": [business_data['id']],
            "name": [business_data['name']],
            "url": [business_data['url']],
            "display_phone": [business_data.get('display_phone')],
            "category": last_category_title,
            "rating": [business_data['rating']],
            "latitude": [business_data['coordinates']['latitude']],
            "longitude": [business_data['coordinates']['longitude']],
            "hours": f'{start_time} - {end_time}'
            }

        # Creating a DataFrame for the Business Details
        df = pd.DataFrame(data)
        dataframes.append(df)
    else:
        print(f"Failed to retrieve details for business with ID {business_id}")

# Concatenating the List of DataFrames into a Single DataFrame
result_df = pd.concat(dataframes, ignore_index=True)

# Viewing the Resulting DataFrame
display_result_df = result_df.head(n=len(result_df))
html_1 = scroll_table(display_result_df, 'result_df_html', "Relevant Scraped Data")
display(HTML(html_1))

# Installing Googlemaps Package
!pip install googlemaps

# Importing Googlemaps Package
import googlemaps

# Creating the Map Client
google_api_key = 'AIzaSyDveCKBL26Y80hDp5XXeyMyJ24G3S2WDpw'
gmaps = googlemaps.Client(key= google_api_key)

# Creating Lists of Latitude and Longitude pairs
latitude_list = list(result_df['latitude'])
longitude_list = list(result_df['longitude'])

# Creating an Empty List to Store the Geocoded Addresses
geocoded_addresses = []

# Finding Formatted Addresss of Each Coordinate Pair
for i in range(len(latitude_list)):
    reverse_geocode_result = gmaps.reverse_geocode((latitude_list[i], longitude_list[i]))

    # Extracting the Formatted Address From the Result
    if reverse_geocode_result:
        formatted_address = reverse_geocode_result[0]['formatted_address']
        geocoded_addresses.append(formatted_address)
    else:
        geocoded_addresses.append("No address found for the given coordinates.")

# Creating a New DataFrame, Selecting Relevant Columns
new_df = result_df[['name', 'url', 'display_phone', 'category', 'rating', 'hours']]
new_df['Address'] = geocoded_addresses

# Viewing the New DataFrame Containing the Formatted Addresses
display_new_df = new_df.head(n=len(new_df))
html_2 = scroll_table(display_new_df, 'new_df_html', "Data Frame with Formatted Addresses")
display(HTML(html_2))

# Renaming the Columns, and Cleaning the DataFrame
new_col_names = {'name': 'Food Truck',
                 'url': 'Website',
                 'display_phone': 'Phone Number',
                 'category': 'Cuisine',
                 'rating': 'Rating',
                 'hours': 'Hours',
                 'Address': 'Address'}
clean_df = new_df.rename(columns = new_col_names).dropna().drop_duplicates().reset_index().drop(columns='index')

# Viewing the New DataFrame Containing the Formatted Addresses
display_clean_df = clean_df.head(n=len(clean_df))
html_3 = scroll_table(display_clean_df, 'clean_df_html', "Cleaned Data Frame")
display(HTML(html_3))

# Converting Hours to Date_Time Format

# Importing Date_Time Package
from datetime import datetime

# Creating List of Open Times
timing = list(clean_df['Hours'])

# Creating Empty Lists to Store Start and End Times
start_times = []
end_times = []

# Splitting Start and End Times
for entry in timing:
    if entry == 'None - None':
        # Replacing 'None - None' Entries with NA values
        start_times.append(None)
        end_times.append(None)
    else:
        # Splitting the Time Range Using ' - ' as the Delimiter
        start_time, end_time = entry.split(' - ')
        start_times.append(start_time)
        end_times.append(end_time)

# Converting Start Times to Date_Time Format
start_times_datetime = [datetime.strptime(time, '%H%M') if time is not None else None for time in start_times]

# Convert End Times to Date_Time
end_times_datetime = [datetime.strptime(time, '%H%M') if time is not None else None for time in end_times]

# Create a DataFrame
time_df = pd.DataFrame({'Start Time': start_times_datetime, 'End Time': end_times_datetime})

# Format the Date_Time Objects as "hh:mm AM/PM"
time_df['Start Time'] = time_df['Start Time'].dt.strftime('%I:%M %p')
time_df['End Time'] = time_df['End Time'].dt.strftime('%I:%M %p')

# Adding Start and End Times to Clean DataFrame
clean_df = clean_df.drop(columns='Hours')
clean_df['Start Time'] = time_df['Start Time']
clean_df['End Time'] = time_df['End Time']

# Creating Final Dataset, After Further Cleaning and Sorting by Rating
final_df = clean_df.dropna().sort_values(by='Rating', ascending=False).reset_index().drop(columns='index')

# Viewing the New DataFrame Containing the Formatted Addresses
display_final_df = final_df.head(n=len(final_df))
html_4 = scroll_table(display_final_df, 'final_df_html', "Final Data Frame")
display(HTML(html_4))

# Exporting Final DataFrame to Excel
final_df.to_excel('Final_Cleaned_DataFrame.xlsx', index=False)

# Downloading Excel File
files.download('Final_Cleaned_DataFrame.xlsx')